## 树状数组
### 动机
**查询**
	给你一个数组，如何快速地计算任意一段连续子数组的元素和？下标从 left 到 right 的子数组元素和，可以看成是下标从 1 到 right 的子数组元素和，减去下标从 1 到 left−1 的子数组元素和。例如数组 [3,1,4,1,5,9]，子数组 [4,1,5] 的元素和，等于 [3,1,4,1,5] 的元素和，减去 [3,1] 的元素和。
	按照这个方法，算出每个前缀 [1,i]（表示下标从 1 到 i 的连续子数组）的元素和，就可以 O(1) 地计算任意连续子数组的元素和了。
**更新**
	但是，如果还可以修改数组中的元素呢？比如我把下标为 1 的元素修改了，由于所有前缀都包含下标 1，那么就需要更新所有前缀的元素和，更新操作就需要 O(n) 的时间，这太慢了。
	能不能把前缀 [1,i] 拆分成若干段连续子数组呢？
	如果拆分得太细，比如拆分成 [1,1],[2,2],[3,3],⋯，虽然更新是 O(1) 的，但计算子数组元素和还是得遍历累加，时间复杂度是 O(n)，太慢了。
**平衡**
	上面的做法，要么询问是 O(1) 更新是 O(n)，要么询问是 O(n) 更新是 O(1)，时间差距悬殊。如何「平衡」询问和更新的时间复杂度？关键在于如何拆分子数组（区间）。能否把任意前缀拆分成若干个关键区间，使得更新操作也只会更新若干个关键区间？这样回答询问时，只需要遍历并累加若干个关键区间的元素和。更新元素时，也只需要遍历并更新若干个关键区间的元素和。

### 如何拆分
如果把一个正整数 i 拆分成若干个不同的 2 的幂（从大到小），那么只会拆分出 O(logi) 个数。对于树状数组的拆分，一般的：
	- 如果i是2的幂次，那么$[ 1,i]$不需要拆分
	- 如果 i 不是 2 的幂，那么先拆分出一个最小的 2 的幂，记作 lowbit(i)（例如 6 拆分出 2），得到长为 lowbit(i) 的关键区间 $[i−lowbit(i)+1,i]$，问题转换成剩下的 $[1,i−lowbit(i)]$ 如何拆分，这是一个规模更小的子问题
如何计算区间和？由于关键区间的右端点互不相同，我们可以把右端点为 i 的关键区间的元素和保存在 $tree[i]$ 中.按照如下方法计算前缀 [1,i] 的元素和：
1. 初始化元素和 s=0。
2. 每次循环，把 tree[i] 加到 s 中，对应关键区间 [i−lowbit(i)+1,i] 的元素和。
3. 然后更新 i 为 i−lowbit(i)，表示接下来要拆分 [1,i−lowbit(i)]，获取其中关键区间的元素和。
4. 循环直到 i=0 为止。
5. 返回 s
要计算 sumRange(left, right)，可以分别计算 [1,right+1] 的元素和（改成下标从 1 开始），以及 [1,left] 的元素和，两者相减即为答案

### 如何更新
假设下标 x 发生了更新，那么所有包含 x 的关键区间都会被更新。

例如下标 5 更新了，那么关键区间 [5,5],[5,6],[1,8],[1,16] 都需要更新，这三个关键区间的右端点依次为 5,6,8,16。

如果在 5-6,6-8,8-16 之间连边（其它位置也同理），我们可以得到一个什么样的结构

![[Pasted image 20250806121510.png]]
证明如下两个命题：
1. 右端点为 x 的关键区间，被右端点为 x+lowbit(x) 的关键区间包含。
2. 右端点在 [x+1,x+lowbit(x)−1] 内的关键区间，与右端点为 x 的关键区间没有任何交集。

对于 update(index, val)，算法如下：
 1. 设 delta=val−nums[index]，相当于把 index 的元素增加了这么多。然后把 nums[index] 更新成 val。
2. 初始化 i=index+1（注意下标从 1 开始），这是第一个被更新的关键区间的右端点。
3. 不断循环直到 i>n，这里 n 是 nums 的长度。
4. 每次循环，把 tree[i] 增加 delta。
5. 然后更新 i 为 i+lowbit(i)，即下一个被更新的关键区间的右端点。


### 如何初始化
``` python title:树状数组 fold
class NumArray_nlogn:

    __slots__ = 'nums', 'tree'

    def __init__(self, nums):

        n = len(nums)

        self.nums = [0]*n

        self.tree = [0]*(n+1)

        for i, x in enumerate(nums):

            self.update(i, x)

    def update(self, i, val):

        delta = val-self.nums[i]

        self.nums[i] = val

        i += 1

        while i< len(self.tree):

            self.tree[i] += delta

            i += i & -i#lowbit(i)的实现方式

    def prefixSum(self, i):

        i += 1

        res = 0

        while i>0:

            res += self.tree[i]

            i -= i & -i

        return res

    def sumRange(self, left, right):

        return self.prefixSum(right) - self.prefixSum(left-1) if left > 0 else self.prefixSum(right)

class NumArray_n:

    __slots__ = 'nums', 'tree'

    def __init__(self,nums):

        n = len(nums)

        self.nunms = nums

        tree = [0]*(n+1)

        for i,x in enumerate(nums,1):#从1开始

            tree[i] += x

            nxt = i+(i&-i)

            if nxt<=n:

                tree[nxt] += tree[i]

        self.tree = tree

    def update(self,index,val):

        delta = val-self.nunms[index]

        self.nums[index] = val

        i = 1+index

        while i<len(self.tree):

            self.tree[i] += delta

            i += i&-i

    def prefixSum(self,i):

        s = 0

        i += 1

        while i>0:

            s += self.tree[i]

            i -= (i&-i)

        return s

    def sumRange(self,left,right):

        return self.prefixSum(right) - self.prefixSum(left-1)
```

## 线段树
### 动机
快速找到某一个区间内的最大(最小值),也是基于二分的思想，但不一定是有序数组。基本是基于二叉树来进行的。

初始化时间复杂度$O(N)$,直接看二叉树的节点
``` python title:线段树 fold
class SegmentTree:
	def __init__(self,a):

        n = len(a)

        self.max = [0]*(4*n)## 4n不是最佳结果，可以用二叉树的性质去推

        self.build(a,1,0,n-1)

    def maintain(self,o): #o表示线段树上的位置

        self.max[o] = max(self.max[2*o],self.max[2*o+1])

    def build(self,a,o,l,r):

        if l==r:

            self.max[o] = a[l]

            return

        m = (l+r)//2

        self.build(a,2*o,l,m)

        self.build(a,2*o+1,m+1,r)

        self.maintain(o)        

    def update(self,o,l,r,i,x): # l,r,i均为a上的index

        if l==r:

            self.max[o] = x

            return

        m = (l+r)//2

        if i<=m:

            self.update(2*o,l,m,i,x)

        else:

            self.update(2*o+1,m+1,r,i,x)

        self.maintain(o)

        return i

    def find_first(self,o,l,r,x):

        if self.max[o]<x:

            return -1

        if l==r:

            return l

        m = (l+r)//2

        i = self.find_first(2*o,l,m,x)

        if i<0:

            i = self.find_first(2*o+1,m+1,r,x)

        return i
```